# Bridge_Tarzan_Graph-  Undirected only
Bridge is an edge, whose deletion increases the graph's number of connected components
Bridge- Only one way to reach (u to v), if there is a bridge, the discovery time of u will always be less than lowest discovery of v and their fellow neighbours, because u always comes before v and its fellow neighbours. THIS IS THE CONCEPT, that all. 
dt[u]< low[v] and not a parent, then there is a bridge. If we have reached u at distance "t" then v will be "t+1" or more, and all other neighbours will be reached even farther. 
Two arrays- Discovery time and Lowest discovery time of all neighbours
Two conditions to understand, how do we update discovery time and lowest discovery timee, second one is when do we check the bridge condition. 
We need to track parent, discovery time and lowest discovery time. Why do we need to track parent? by doing this we ensure that the bridge condition correctly identifies true bridges rather than mistakenly identifying the parent child edge as a Bride. because parent distance obviously will be more than child. 
Now, how do we implement the code, a) if the node is parent, we don't do anything, we just continue (we cannot say if it is a bridge or not) b) if a node is not visited, we perform DFS, we go on updating the disc and low, once we go to the depth and all neighbours are transvered, while we are backtracking we update the Low discovery by checking low of curr and low of neighbour. HERE we check the bridge condition  "if dt[u]< low[v]". c)   if it is visited already, then definitely this is not bridge and most important, if it was already visited then that means, it was discovered earlier, so  we will have to update the Lowest discovery time - by checking lowest of curr and discovery of neigh
IMPORTANT: Why did we update the lowest discovery while backtracking when we performed DFS: SIMPLIFIED EXPLANATION: Let's think of it as updating your knowledge of the quickest possible travel routed: A. Direct routes(traversing)- Intially, you record your arrival times based on direct travel. B. Discovering Shortcuts(already oka visited dorkithe): As you visit other cities, you might discover that some cities could have been reached earlier through different routes. C. Updating Knowledge(updating low values): When returning from the visit(backtracking), you update the earliest possible arrival times for the cities visited, reflecting the quickest routes discovered.       
WHY did we use discovery time (disc) of the neighbour instead of its low value, when neighbour is already visited? Using discovery time of the neighbour when its already visited (back edge) helps in considering direct routes back to earlier visited cities. This ensures the most accurate reflection of possible shortcuts and helps in identifying critical connections. In contrast, for non-back edge connections. 
Simple put, track par, disc, low. If node is already vis, no bridge, if it not visited, perform DFS, update times, while backtracking update lowest of needed, check bridge condition.
